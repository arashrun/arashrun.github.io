---
title: keyword-c++
date: 2023-03-06 00:24:27
categories:
- c++
tags:
- c++
---


![](/images/cpp20关键字.png)


#### <font color="#ff0000"><center>const(常量)</center></font>

> 作用：
>
> const ==> constant (adj.不变的,不可修改的)
>
> 起因：
>
> 使用场景：

1. const char * a
2. char const \*a
	上面两种都是指明*a的内容不可修改。
3. char * const a
	代表指针a不可修改。
4. void func() const
	代表被修饰函数不能修改任何成员变量值，不能调用非const函数。且不加const和加了const的同名函数是不一样的。


#### <font color="#ff0000"><center>static(静态)</center></font>

> static (adj.静态的，不会被删除的,可修改)
>
> 百度百科-static 		https://baike.baidu.com/item/static/9598919?fr=aladdin#1

**面向过程中**

1. 静态全局变量:

- 静态全局变量保存在<u>全局数据区</u>    (生命周期)
- 未经初始化的静态全局变量会被程序自动初始化为0    (由于保存在全局数据区)
- 静态全局变量在声明它的<u>整个文件都是可见</u>的，而在文件之外是不可见的    (作用域)

2. 静态局部变量:

- 静态局部变量保存在<u>全局数据区</u>    (生命周期)
- 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0  (由于保存在全局数据区)
- 它始终驻留在全局数据区，直到程序运行结束。但其<u>作用域</u>为局部作用域    (作用域)

3. 静态函数:

- 静态函数不能被其它文件所用其它文件中可以定义相同名字的函数，不会发生冲突


**面向对象中**

1. 静态数据成员:

- 静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用
- 静态数据成员存储在全局数据区, 在没有产生类对象时其[作用域](https://baike.baidu.com/item/作用域)就可见，即在没有产生类的实例时，我们就可以操作它
- 静态数据成员定义时要分配空间，所以不能在类声明中定义
- 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性

2. 静态成员函数:




---

#### constexpr

> 语义是“常量表达式”，也就是在编译期可求值的表达式



---

#### explicit 

​	explicit构造函数是用来防止隐式转换的

```c++
class Test1
{
public:
    Test1(int n)
    {
        num=n;
    }//普通构造函数
private:
    int num;
};
//--------------------------------------------
class Test2
{
public:
    explicit Test2(int n)
    {
        num=n;
    }//explicit(显式)构造函数
private:
    int num;
};
//----------------------------------------------
int main()
{
    Test1 t1=12;//隐式调用其构造函数,成功
    Test2 t2=12;//编译错误,不能隐式调用其构造函数
    Test2 t2(12);//显式调用成功
    return 0;
}
```



---

#### =delete



---

#### =default



---

#### noexcept=default



---

#### noexcept
