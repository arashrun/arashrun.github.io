---
title: 设计模式
date: 2025-02-27 17:04:57
categories:
  - cs基础
tags:
  - 设计模式
---

## qt中的设计模式


Qt 框架广泛使用了各种设计模式，以实现其灵活性、可扩展性和可维护性。以下是 Qt 中用到的一些主要设计模式：

**1. 对象创建型模式 (Creational Patterns)**

*   **工厂方法模式 (Factory Method):**
    *   `Q_DECLARE_METATYPE` 和 `qRegisterMetaType` 宏以及相关的 `QMetaType` 系统，允许创建未知类型的对象（在运行时确定类型）。
    *   `QPluginLoader` 使用工厂方法来加载和创建插件对象。

*   **抽象工厂模式 (Abstract Factory):**
    *   `QStyle` 类及其子类（如 `QWindowsStyle`, `QMacStyle`）提供了一个抽象工厂，用于创建与平台相关的 UI 元素外观（按钮、滚动条等）。

*   **单例模式 (Singleton):**
    *   `QApplication` 类（通常通过全局的 `qApp` 指针访问）是一个单例，代表整个应用程序。
    *   `QCoreApplication::instance()` 也是一个单例。
*  **原型模式 (Prototype)**
    *   `QObject::clone()` 可以创建一个新的对象，它是现有对象的副本。虽然Qt中不直接叫`clone()`, 但是`Q_DECLARE_COPY`以及相关拷贝构造函数均可以看作是原型模式的应用.

**2. 结构型模式 (Structural Patterns)**

*   **适配器模式 (Adapter):**
    *   `QAbstractItemModel` 为各种不同的数据源（列表、树、表格等）提供了一个统一的接口，使它们可以与 `QListView`、`QTreeView`、`QTableView` 等视图组件一起使用。
    *   信号和槽机制，在某种程度上也可以看作是适配器模式的一种体现，但主要还是观察者模式。它将信号的发送者和槽的接收者解耦，信号可以看作是一个“适配器”，将发送者的动作转换为接收者可以理解的调用。

*   **组合模式 (Composite):**
    *   Qt 的部件（Widget）层次结构是组合模式的典型应用。`QWidget` 可以包含其他 `QWidget`（作为子部件），形成一个树形结构。

*   **装饰器模式 (Decorator):**
    *   `QLayout` 可以用来动态地向部件添加布局管理，而无需修改部件本身。
    * `QGraphicsEffect`类及其子类（如`QGraphicsBlurEffect`）可以为`QGraphicsItem`添加额外的视觉效果。

*   **外观模式 (Facade):**
    *   `QNetworkAccessManager` 为网络请求（HTTP, FTP 等）提供了一个更高层次、更易于使用的接口，隐藏了底层的复杂性。

*   **代理模式 (Proxy):**
    *   `QSortFilterProxyModel` 可以在不修改原始数据模型的情况下，对数据进行排序和过滤，然后将结果呈现给视图。
    *   `QIdentityProxyModel`将源模型数据直接传递给视图，不做任何修改，这也可以看作是代理模式最简单的形式。

**3. 行为型模式 (Behavioral Patterns)**

*   **观察者模式 (Observer):**
    *   Qt 的信号和槽机制是观察者模式的经典实现。一个对象（信号发送者）的状态变化会通知其他对象（槽接收者）。

*   **策略模式 (Strategy):**
    *   `QAbstractButton` 的不同子类（`QPushButton`, `QCheckBox`, `QRadioButton`）实现了不同的按钮行为。
    *   `QTextCodec`及其子类(`QTextCodec::codecForName("UTF-8")`)为文本编码和解码提供了不同的策略。

*   **模板方法模式 (Template Method):**
    *   许多 Qt 类都定义了虚拟函数，允许子类重写这些函数以自定义行为，而无需改变类的整体结构。例如，`QWidget::paintEvent`、`QWidget::mousePressEvent` 等事件处理函数。
    *   `QAbstractItemModel` 也定义了一系列虚函数, 子类必须实现这些函数以提供特定的数据访问方式.

*   **迭代器模式 (Iterator):**
    *   Qt 提供了各种迭代器类，如 `QListIterator`, `QMapIterator`, `QHashIterator` 等，用于遍历容器中的元素。

*   **状态模式 (State):**
     *  `QStateMachine` 类允许对象根据其内部状态改变其行为, 内部使用了状态模式.
     *   `QAbstractAnimation`及其子类(`QPropertyAnimation`)也可以看作是状态模式的一种应用.

*   **命令模式 (Command):**
    *   `QUndoCommand` 类表示一个可以执行和撤销的操作，常用于实现撤销/重做功能。

**其他一些模式:**

*   **中介者模式 (Mediator):**
    *   `QDialog` 可以作为多个部件之间的中介者，协调它们之间的交互。

*   **备忘录模式 (Memento):**
    *   `QUndoStack`使用`QUndoCommand`类来实现了撤销/重做功能,其中用到了备忘录模式.

**总结:**

这只是 Qt 框架中使用的一些主要设计模式。Qt 的设计非常灵活和强大，很多地方都体现了设计模式的思想。理解这些设计模式有助于更好地理解 Qt 的工作原理，并编写出更优雅、可维护的 Qt 代码。 并非所有的 Qt 类都严格遵循某一种设计模式，有些类的设计可能融合了多种模式的思想。



## 为什么要叫做结构型模式和行为型模式？如何理解这种分类

将设计模式分为**结构型模式 (Structural Patterns)** 和 **行为型模式 (Behavioral Patterns)** 是一种根据模式的**关注点**和**目的**进行分类的方法。这种分类方式有助于理解和记忆不同的设计模式，并选择合适的模式来解决特定问题。

**1. 结构型模式 (Structural Patterns):**

*   **关注点：** 对象的**组成**和**结构**。
*   **目的：**
    *   将类或对象组合成更大的结构，通常是更复杂、更灵活的结构。
    *   简化类或对象之间的关系。
    *   提高代码的可复用性和可维护性。
*   **理解：**
    *   关注 *如何* 将类和对象 *组合* 在一起，形成更大的系统。
    *   可以把它们想象成建筑的 *蓝图*，展示了不同部分如何 *连接* 和 *组织*。
    *   它们处理的是 *静态* 的关系（在编译时或对象创建时确定）。
*   **例子：**
    *   **适配器模式 (Adapter):** 将一个类的接口转换成客户希望的另一个接口。就像电源适配器可以将不同国家的插头转换成你的设备可以使用的插头一样。
    *   **组合模式 (Composite):** 将对象组合成树形结构来表示“部分-整体”的层次结构。就像文件系统中的文件夹可以包含文件和其他文件夹一样。
    *   **装饰器模式 (Decorator):** 动态地给一个对象添加一些额外的职责。就像给一个普通蛋糕加上奶油、水果等装饰一样。
    *   **外观模式 (Facade):** 为子系统中的一组接口提供一个统一的接口。就像一个复杂的音响系统，你只需要操作几个按钮，而不需要了解内部的复杂电路一样。
    *   **代理模式 (Proxy):** 为其他对象提供一种代理以控制对这个对象的访问。就像一个明星的经纪人，负责安排明星的日程和处理各种事务一样。

**2. 行为型模式 (Behavioral Patterns):**

*   **关注点：** 对象之间的**交互**和**责任分配**。
*   **目的：**
    *   描述对象之间的通信方式。
    *   定义对象的行为和职责。
    *   提高代码的灵活性和可扩展性。
*   **理解：**
    *   关注对象 *如何* *交互* 和 *协作* 来完成任务。
    *   可以把它们想象成组织中 *不同部门* 之间的 *工作流程* 和 *职责分配*。
    *   它们处理的是 *动态* 的关系（在运行时确定）。
*   **例子：**
    *   **观察者模式 (Observer):** 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。就像报纸的订阅者，当有新报纸出版时，所有订阅者都会收到一份一样。
    *   **策略模式 (Strategy):** 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。就像你可以选择不同的排序算法（冒泡排序、快速排序等）来对数据进行排序一样。
    *   **模板方法模式 (Template Method):** 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。就像泡茶的步骤（烧水、放茶叶、倒水、喝茶）是固定的，但你可以选择不同的茶叶一样。
    *   **迭代器模式 (Iterator):** 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。
    *   **状态模式 (State):** 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。就像红绿灯的状态变化（红灯、绿灯、黄灯）会导致不同的交通行为一样。
     *  **命令模式 (Command):**将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

**总结：**

*   **结构型模式：** 关注 *如何构建* 对象和类，形成更大的结构。
*   **行为型模式：** 关注对象之间 *如何交互* 和 *协作*，完成任务。

这种分类方法不是绝对的，有些模式可能同时具有结构型和行为型的特征。 但总的来说，这种分类提供了一种有用的框架，可以帮助我们更好地理解和应用设计模式。

**类比:**

可以把设计模式的分类想象成盖房子：

*   **创建型模式 (Creational):** 就像选择使用什么材料（木头、砖块、混凝土）来建造房子，以及如何生产这些材料（工厂、预制件）。
*   **结构型模式 (Structural):** 就像房子的设计图，决定了房间的布局、墙的位置、门窗的大小等。
*   **行为型模式 (Behavioral):** 就像房子里面的活动，人们如何在房间之间走动、如何使用电器、如何进行日常活动。

通过这个类比，可以更直观地理解不同类型的设计模式之间的区别和联系。